var EE = require('events').EventEmitter
  , ResourcePool = require(__dirname + '/ResourcePool.js')
  , inherits = require('util').inherits
  ;

function AutoResourcePool(rcProp, rcCreateFunc, rcDestroyEvent, minTotal, maxTotal, minSpare, maxSpare){
  this.rcProp = rcProp || 'rc';
  this.rcCreateFunc = rcCreateFunc;
  this.rcDestroyEvent = rcDestroyEvent;
  this.minTotal = minTotal;
  this.maxTotal = maxTotal;
  this.minSpare = minSpare;
  this.maxSpare = maxSpare;
  this.freeList = new Array();
  this.busyCount = 0;
  this.adjustAmount();
}

AutoResourcePool.prototype.check = function(){
  return !!this.freeList.length;
}

AutoResourcePool.prototype.count = function(option){
  var slot = this.freeList.shift();
  option[this.rcProp] = slot.rc;
  if (this.freeList.length === this.minSpare) {
    // auto create a new spare rc
    // but if maxTotal is about over, cancel it
  }
  this.busyCount++;
}

AutoResourcePool.prototype.actcb = function(err, result, option){
  // whatever act fin or err or both,
  // return rc to freelist and avoid repeat
  if (option.rc) {
    this.freeList.unshift(option.rc);
    delete option.rc;
    this.busyCount--;
  }
  return true;
}

AutoResourcePool.prototype.adjustAmount = function(){
  var me = this
    , total = this.busyCount + this.freeList.length
    , lack = Math.max(this.minTotal - total, this.minSpare - this.freeList.length)
    , redundant = ((lack >= 0) ? 0 : (this.maxSpare - this.freeList.length))
    ;
  for (var i = 0; i < lack; i++) {
    this.rcCreateFunc(function(rc){
      me.addRC(rc);
    });
  }
  for (var i = 0; i < redundant; i++) {
    this.freeList.pop()[this.destroyMethod]();
  }
}

AutoResourcePool.prototype.addRC = function(rc){
  this.freeList.push(rc);
  var me = this;
  rc.on(this.rcDestroyEvent, function(){
    var index = me.freeList.indexOf(rc);
    if (~index) {
      me.freeList.splice(index, 0);
    } else {
      // report busy rc destroyed error
    }
  });
  this._resume();
}

AutoResourcePool.prototype.removeRC = function(rc){
  this.freeList.splice(this.freeList.indexOf(rc), 0);
}

/*
因为创建资源往往是经过I/O的，因此比较慢，因此需要提前准备好一定量的 spare resource。
这样，在需要资源时，可以马上使用。
但是在缺少对资源需求的情况下，保持大量的空闲 spare resource 又是一种浪费，包括对自身和对端服务器都存在浪费。
因此需要 max spare server.
回头使用连接 mongoose 来测试本包
 */