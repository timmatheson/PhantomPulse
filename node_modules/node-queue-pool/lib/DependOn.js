function DependOn(maxConcurrency){
  this._length = 0;
  this.idWaits = {};
  this.freeQueue = [];
}

DependOn.prototype.push = function(option){
  this._length++;
}

DependOn.prototype.shift = function(option){
  this._length--;
}

DependOn.prototype.unshift = function(option){
  this._length++;
}

Object.defineProperty(PriorityQueue.prototype, 'length', {
  get : function(){
    return this._length;
  },
  enumerable : true
});


DependOn.prototype.check = function(option){
  return !option.refs;
}

DependOn.prototype.count = function(option){
  this.ids[option.id] = false;
}

DependOn.prototype.actcb = function(option){
  this.ids[option.id] = true;
  return true;
}

exports.class = DependOn;

/*
 check option.depend 是否还有值

 相互依赖的动作要对 option 填写 id , refs 字段，
 分别记录自己的id和依赖动作的id.
 .check 发现存在非空 refs 字段，就先检查是否这些被依赖的动作是否执行完了，
 执行完了的动作会保存其结果 this.ids[id] = result，
 动作执行完的同时，要将依赖其的动作的option.refs 减去自己，
 并且当 option.refs 无项目时，执行它。。。
 不过这和 super-queue 先进先出的原则相悖了，抑或是说它压根就不是 queue 了。
 结论：
 应该将自动依赖处理独立成包
 */

function AutoDepend(){
  this.fin = false;
}
AutoDepend.prototype.add = function(id, func, refs){

  // when all executed, emit end
}

AutoDepend.prototype.end = function(){
  this.fin = true;
}

/*
 func main(a,b,c)
 helper = new Depend(main, a, b, c)
 call.then(function(err,rval){helper.resolve(a,rval)});
 */