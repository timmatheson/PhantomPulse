/**
 * Created with JetBrains WebStorm.
 * User: kaven276
 * Date: 12-10-18
 * Time: 下午12:19
 */

var EventEmitter = require('events').EventEmitter
  , PriorityQueue = require('..').PriorityQueue
  ;

function noop(cb){
  cb && cb();
}

function Slot(slotNo, execOrder, desc){
  this.slotNo = slotNo;
  this.order = execOrder;
  this.desc = desc;
  this.startTime = Date.now();
}

function Action(act, desc){
  this.act = act;
  this.desc = desc;
}

/**
 * @param maxConcurrency
 * @param timeout
 * @constructor
 */
function ActionQueue(maxConcurrency, timeout){
  var me = this;
  EventEmitter.call(this);
  this.maxConcurrency = maxConcurrency;
  this.maxPriority = 1;
  this.suspending = false;
  var freeSlots = this.freeSlots = new Array(maxConcurrency);
  for (var i = 0; i < maxConcurrency; i++) {
    freeSlots[i] = i;
  }
  this.slots = new Array(maxConcurrency);
  this.maxError = Number.POSITIVE_INFINITY;
  this.timeout = timeout = timeout || 3000;
  this.queue = [];
  this.result = undefined;
  this.closed = false;
  this.breaked = false;
  this.doLog = false;

  // following are statistics related members
  this.startTime = Date.now();
  this.totolTime = 0;
  this.execCount = 0;
  this.timeoutCount = 0;
  this.succeedCount = 0;
  this.failureCount = 0;
  this.lateCount = 0;

  this.onBeforeResume = noop;
  this.onAfterResume = undefined;
  this.onBeforeSuspend = undefined;
  this.onAfterSuspend = undefined;

  setInterval(function(){
    var slots = me.slots;
    for (var i = 0; i < maxConcurrency; i++) {
      var slot = slots[i];
      if (slot && (Date.now() - slot.startTime > timeout)) {
        me.doLog && console.warn('slot %d is timeout(%dms) and force released! %j', i, Date.now() - slot.startTime, slot);
        me.doLog && me.log('timeout:' + slot.desc);
        me.timeoutCount++;
        me._release(i);
        me.emit('timeout', slot.startTime, Date.now() - slot.startTime, slot.desc);
      }
    }
  }, 1000);
}
require('util').inherits(ActionQueue, EventEmitter);

ActionQueue.prototype.usePriorityQueue = function(maxPriorityLevel, defaultLevel){
  this.queue = new PriorityQueue(maxPriorityLevel, defaultLevel);
  this.maxPriority = maxPriorityLevel;
  return this;
};

ActionQueue.prototype.setMaxError = function(maxError){
  this.maxError = maxError || 0;
  return this;
};

ActionQueue.prototype.setLogSwitch = function(tf){
  if (tf === undefined) tf = true;
  this.doLog = tf;
  return this;
};

ActionQueue.prototype.log = function(str){
  console.log(' - ', str);
};

ActionQueue.prototype.toString = function(){
  return {
    setting : {
      maxConcurrency : this.maxConcurrency,
      maxPriority : this.maxPriority,
      timeout : this.timeout
    },
    stats : {
      suspending : this.suspending,
      execCount : this.execCount,
      executingCount : this.maxConcurrency - this.freeSlots.length,
      succeedCount : this.succeedCount,
      failureCount : this.failureCount,
      timeoutCount : this.timeoutCount,
      lateCount : this.lateCount,
      freeSlotCount : this.freeSlots.length,
      waitingCount : this.queue.length,
      totolTime : this.totolTime + ' ms',
      avgTime : Math.round(this.totolTime / this.execCount) + ' ms',
      duration : (Date.now() - this.startTime) + ' ms',
      rate : Math.round(this.execCount / (Date.now() - this.startTime) * 1000, 1)
    }
  };
}

ActionQueue.prototype.quit = function(err){
  if (this.breaked) return;
  this.breaked = true;
  this.suspend();
  this.queue = undefined;
  this.close();
  this.emit('close', err);
}

ActionQueue.prototype._release = function(slotNo){
  var waitingAct
    ;
  if (!this.suspending) {
    waitingAct = this.queue.shift();
  }
  this.totolTime += (Date.now() - this.slots[slotNo].startTime);
  if (waitingAct) {
    this._exec(slotNo, waitingAct.act, waitingAct.desc);
  } else {
    this.freeSlots.push(slotNo);
    this.slots[slotNo] = undefined;
    if (this.freeSlots.length === this.maxConcurrency) {
      this.emit('drain');
      if (this.closed && !this.breaked) {
        this.emit('close', undefined, this.result);
      }
    }
  }
}

ActionQueue.prototype._exec = function(slotNo, act, desc){
  var me = this;
  this.slots[slotNo] = new Slot(slotNo, this.execCount++, desc);
  this.doLog && me.log('start:' + desc);
  act(function(err){
    if (me.breaked) return;
    if (err) {
      me.doLog && me.log('failure: ' + desc);
      if (++me.failureCount >= me.maxError && !me.breaked) {
        me.quit(err);
      }
    } else {
      me.succeedCount++;
      me.doLog && me.log('succeed: ' + desc);
    }
    if (me.slots[slotNo] === undefined) {
      me.lateCount++;
      me.doLog && me.log('late: ' + desc);
      me.doLog && console.log('slot is timeout already!');
      return;
    }
    me._release(slotNo);
  });
}

/**
 * add a act with priority and description
 * @param priority {number} optional
 * @param desc {string} optional
 * @param act {function}
 * @return {*}
 */
ActionQueue.prototype.enqueue = function(priority, desc, act){

  if (this.closed) {
    throw new Error('ActionQueue is closed, no more request is allowed');
  }

  if (typeof priority !== 'undefined' && typeof priority !== 'number') {
    desc = priority;
    act = desc;
    priority = undefined;
  }
  if (typeof desc === 'function') {
    act = desc;
    desc = '?';
  }

  var slotNo;
  if (!this.suspending || priority === 0) {
    slotNo = this.freeSlots.pop();
  }

  if (slotNo === undefined) {
    if (this.queue.maxLevel) {
      this.queue.push(priority, new Action(act, desc));
    } else {
      this.queue.push(new Action(act, desc));
    }
  } else {
    this._exec(slotNo, act, desc);
  }
  return this;
}

ActionQueue.prototype.suspend = function(){
  this.suspending = true;
}

ActionQueue.prototype._resume = function(){
  var maxResumed = Math.min(this.freeSlots.length, this.queue.length)
    ;
  this.suspending = false;
  for (var i = 0; i < maxResumed; i++) {
    var waitingAct = this.queue.shift()
      , slotNo = this.freeSlots.pop()
      ;
    this._exec(slotNo, waitingAct.act, waitingAct.desc);
  }
}

ActionQueue.prototype.regBeforeResume = function(cb){
  console.warn('registered onBeforeResume');
  this.onBeforeResume = cb;
}

ActionQueue.prototype.resume = function(cb){
  var me = this;
  this.emit('beforeResume');
  this.onBeforeResume(function(err){
    console.warn('onBeforeResume returned');
    if (err) {
      console.warn(err);
      cb && cb(err);
      return;
    }
    me._resume();
    cb && cb();
    me.emit('afterResume');
  });
}

/**
 * ensure no more request will arrive
 * when all pending request is finished, emit end event
 * if cb is given, bind it to on('emit')
 * @param cb
 */
ActionQueue.prototype.close = function(cb){
  this.closed = true;
  cb && this.on('close', cb);
}

ActionQueue.prototype.push = ActionQueue.prototype.enqueue;
ActionQueue.prototype.end = ActionQueue.prototype.close;

exports.class = ActionQueue;
