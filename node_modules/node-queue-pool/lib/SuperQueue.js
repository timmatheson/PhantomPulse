function Action(act, option){
  this.act = act;
  this.option = option || {};
}

var EE = require('events').EventEmitter
  , util = require('util')
  ;

function SuperQueue(){
  EE.call(this);
  this.pending = 0;
  this.suspending = false;
  this.isEnd = false;
  this.limiters = [];
  this.plugins = this.fn = {};
  this.limiters4check = [];
  this.limiters4count = [];
  this.limiters4actcb = [];
  this.queue = [];
  this.act = null;
}
util.inherits(SuperQueue, EE);

SuperQueue.prototype.setAct = function(act){
  this.act = act;
  return this;
}

SuperQueue.prototype.useCache = function(cache){
  this.cache = cache;
  return this;
}

SuperQueue.prototype.useQueue = function(queue){
  this.queue = queue;
  return this;
};

SuperQueue.prototype.end = function(cb){
  this.isEnd = true;
  cb && this.on('end', cb);
  if (this.pending === 0 && this.queue.length === 0)  this.emit('end');
};

/**
 * limiter should implement count[,check,actcb]
 * @param limiter
 */
SuperQueue.prototype.addLimiter = function(limiter, name){
  this.limiters.push(limiter);
  limiter.count && this.limiters4count.push(limiter);
  limiter.check && this.limiters4check.push(limiter);
  limiter.actcb && this.limiters4actcb.push(limiter);
  if (limiter.check) {
    limiter._resume = this._resume.bind(this);
  }
  if (name) {
    this.plugins[name] = limiter;
  }
  return this;
}

SuperQueue.prototype.enqueue = function(option, act){
  if (this.cache && this.cache.check(option)) {
    (act || this.act)(option);
    return true;
  } else if (this.queue.length) {
    // to ensure FIFO order, and avoid unnecessary checks
    this.queue.push(new Action(act, option));
    return false;
  } else if (this._check(option)) {
    this._exec(act, option || {});
    return true;
  } else {
    this.queue.push(new Action(act, option));
    return false;
  }
}

SuperQueue.prototype._check = function(option){
  var limiters = this.limiters4check
    , len = limiters.length
    ;
  for (var i = 0; i < len; i++) {
    if (!limiters[i].check(option)) {
      this.suspending = true;
      return false;
    }
  }
  this.suspending = false;
  return true;
}

/**
 * Note: It must be called when all limits say pass
 * @param act
 * @param option
 * @private
 */
SuperQueue.prototype._exec = function(act, option){
  var me = this;
  me.limiters4count.forEach(function(limiter){
    limiter.count(option);
  });
  me.pending += (option.amount || 1);
  var canResume = true;
  (act || this.act)(option, function actCB(err, result){
    if (!err && option.cacheKey) {
      me.cache && me.cache.save(option, result);
    }
    me.limiters4actcb.forEach(function(limiter){
      var rval = limiter.actcb(err, result, option);
      canResume = canResume && rval;
    });
    canResume && me._resume();
    me.pending--;
    if (me.pending === 0 && me.queue.length === 0) {
      me.emit('drain');
      if (me.isEnd) {
        me.emit('end');
      }
    }
  });
}

SuperQueue.prototype._resume = function(){
  var action
    , cache = this.cache
    , reduce = false
    ;
  while (action = this.queue.shift()) {
    reduce = true;
    if (cache && cache.check(action.option)) {
      (action.act || this.act)(action.option);
    } else if (this._check(action.option)) {
      this._exec(action.act, action.option);
    } else {
      this.queue.unshift(action);
      return;
    }
  }
  reduce && this.emit('allFired');
}

exports.class = SuperQueue;